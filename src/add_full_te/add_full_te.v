//
// Filename: "add_full_te.v"
//
// Project: Троичный процессор для RISC-V
//
// Description: Операция инверсия трита. Мнемоника ADD_FULL_TE.
//
// Create date: 11.03.2025
// Edit date:   15.03.2025
//
//
// Author:      Vladimir Vasilev
// E-mail:      askfind@ya.ru
//
// GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007
//

// Таб.1 Алфавит троичной симметричной системы счисления
// +--------------------------+-------+-------+-------+
// | Числа                    |  -1   |   0   |   1   |
// +--------------------------+-------+-------+-------+
// | Логика                   | false |  nil  | true  |
// +--------------------------+-------+-------+-------+
// | Логика                   |   f   |   n   |   t   |
// +--------------------------+-------+-------+-------+
// | Символы                  |   -   |	  0   |	  +   |
// +--------------------------+-------+-------+-------+
// | Символы                  |   N   |	  Z   |	  P   |
// +--------------------------+-------+-------+-------+
// | Символы                  |   N   |	  O   |	  P   |
// +--------------------------+-------+-------+-------+
// | Символы                  |   0   |	  i   |	  1   |
// +--------------------------+-------+-------+-------+
// | Символы                  |   v   |	  0   |	  ^   |
// +--------------------------+-------+-------+-------+

//
// trit = {-1,0,1}  - значения трита
//
// Кодирование трита и интерпретация trit:
//
// a[1:0] -> {1,0} = '+1'
// a[1:0] -> {0,0} =  '0'
// a[1:0] -> {0,1} = '-1'
// a[1:0] -> {1,1} = 'Error'
//

// Таб.2 Таблица полного сумматора тритов
// .-----------------------------------------.
// | Перенос из n-1   -1  -1  -1   1   1   1 |
// | 1-е слагаемое    -1  -1  -1   1   1   1 |
// | 2-е слагаемое    -1   0   1  -1   0   1 |
// | Сумма   	       0   1  -1   1  -1   0 |
// | Перенос в n+1    -1  -1   0   0   1   1 |
// .-----------------------------------------.
// Полный сумматор двух тритов с переносом

module add_full_te (
    input  [1:0] carry_in,     // Перенос из n-1: -1, 0, 1
    input  [1:0] a,            // Первое слагаемое: -1, 0, 1
    input  [1:0] b,            // Второе слагаемое: -1, 0, 1
    output reg[1:0] sum,          // Сумма: -1, 0, 1
    output reg[1:0] carry_out,    // Перенос в n+1: -1, 0, 1
    output err                 // Достоверное вычисление
);

always @(*) begin
    case ({carry_in, a, b})
        // Перенос из n-1 = -1, Первое слагаемое = -1, Второе слагаемое = -1
        {2'b01, 2'b01, 2'b01}: begin
            sum = 2'b00;  // Сумма = 0
            carry_out = 2'b01; // Перенос в n+1 = -1
        end
        // Перенос из n-1 = -1, Первое слагаемое = -1, Второе слагаемое = 0
        {2'b01, 2'b01, 2'b00}: begin
            sum = 2'b10;  // Сумма = 1
            carry_out = 2'b01; // Перенос в n+1 = -1
        end
        // Перенос из n-1 = -1, Первое слагаемое = -1, Второе слагаемое = 1
        {2'b01, 2'b01, 2'b10}: begin
            sum = 2'b01;  // Сумма = -1
            carry_out = 2'b00; // Перенос в n+1 = 0
        end
        // Перенос из n-1 = 1, Первое слагаемое = 1, Второе слагаемое = -1
        {2'b10, 2'b10, 2'b01}: begin
            sum = 2'b10;  // Сумма = 1
            carry_out = 2'b00; // Перенос в n+1 = 0
        end
        // Перенос из n-1 = 1, Первое слагаемое = 1, Второе слагаемое = 0
        {2'b10, 2'b10, 2'b00}: begin
            sum = 2'b01;  // Сумма = -1
            carry_out = 2'b10; // Перенос в n+1 = 1
        end
        // Перенос из n-1 = 1, Первое слагаемое = 1, Второе слагаемое = 1
        {2'b10, 2'b10, 2'b10}: begin
            sum = 2'b00;  // Сумма = 0
            carry_out = 2'b10; // Перенос в n+1 = 1
        end
        // Остальные случаи (по умолчанию)
        default: begin
            sum = 2'b00;  // Сумма = 0
            carry_out = 2'b00; // Перенос в n+1 = 0
        end
    endcase
end

assign err = ( (carry_in == 2'b11) || (a == 2'b11) || (b == 2'b11) || (sum == 2'b11) || (carry_out == 2'b11) ) ? 1 : 0;

endmodule
