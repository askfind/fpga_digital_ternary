//
// Filename: "xor_te.v"
//
// Project: Троичный процессор для RISC-V
//
// Description: Операция инверсия трита. Мнемоника XOR_TE.
//
// Create date: 11.03.2025
// Edit date:   15.03.2025
//
//
// Author:      Vladimir Vasilev
// E-mail:      askfind@ya.ru
//
// GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007
//

// Таб.1 Алфавит троичной симметричной системы счисления
// +--------------------------+-------+-------+-------+
// | Числа                    |  -1   |   0   |   1   |
// +--------------------------+-------+-------+-------+
// | Логика                   | false |  nil  | true  |
// +--------------------------+-------+-------+-------+
// | Логика                   |   f   |   n   |   t   |
// +--------------------------+-------+-------+-------+
// | Символы                  |   -   |	  0   |	  +   |
// +--------------------------+-------+-------+-------+
// | Символы                  |   N   |	  Z   |	  P   |
// +--------------------------+-------+-------+-------+
// | Символы                  |   N   |	  O   |	  P   |
// +--------------------------+-------+-------+-------+
// | Символы                  |   0   |	  i   |	  1   |
// +--------------------------+-------+-------+-------+
// | Символы                  |   v   |	  0   |	  ^   |
// +--------------------------+-------+-------+-------+

//
// trit = {-1,0,1}  - значения трита
//
// Кодирование трита и интерпретация trit:
//
// a[1:0] -> {1,0} = '+1'
// a[1:0] -> {0,0} =  '0'
// a[1:0] -> {0,1} = '-1'
// a[1:0] -> {1,1} = 'Error'
//


// Таб.2 Троичное исключающее или
//       XOR
// .-----------------------.
// |     | -1  |  0  |  1  |
// |-----------------------|
// | -1  |  -  |  0  |  +  |
// |-----------------------|
// |  0  |  0  |  0  |  0  |
// |-----------------------|
// |  1  |  +  |  0  |  -  |
// .-----------------------.



module xor_te(a,b,c,err);

input  [1:0] a;
input  [1:0] b;
output reg[1:0] c;
output err;

always @(*) begin
    case ({a, b})
        4'b0000: c = 2'b00; // a=0, b=0 -> c=0
        4'b0001: c = 2'b00; // a=0, b=1 -> c=0
        4'b0010: c = 2'b00; // a=0, b=2 -> c=0
        4'b0100: c = 2'b01; // a=1, b=0 -> c=1
        4'b0101: c = 2'b00; // a=1, b=1 -> c=0
        4'b0110: c = 2'b10; // a=1, b=2 -> c=2
        4'b1000: c = 2'b10; // a=2, b=0 -> c=2
        4'b1001: c = 2'b00; // a=2, b=1 -> c=0
        4'b1010: c = 2'b01; // a=2, b=2 -> c=1
        default: c = 2'b00; // По умолчанию c=0
    endcase
end

assign err = ( (a == 2'b11) || (b == 2'b11) || (c == 2'b11) ) ? 1 : 0;

endmodule
